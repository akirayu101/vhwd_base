<html><head><title>threading</title><link rel="Stylesheet" type="text/css" href="DocStyle.css" /></head><body><div><H1><a name="Condition">Condition</a>
</H1><hr /><P>条件类，与Mutex一起使用。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>wait</td><td>等待事件发生。</td></tr><tr><td>wait_for</td><td>等待事件发生或超时。</td></tr><tr><td>wait_until</td><td>等待事件发生或到某个时间点。</td></tr><tr><td>notify_one</td><td>唤醒一个等待的线程。</td></tr><tr><td>notify_all</td><td>唤醒所有等待的线程。</td></tr></tbody></table><br /><H1><a name="Coroutine">Coroutine</a>
</H1><hr /><P>带有完整栈的协程，在协程切换中，会保存和恢复部分寄存器的值，按约定，X86是EBP,EBX,ESI,EDI会被保存和恢复，X64情况下，RBP,RBX,RSI,RDI和R12~R15会被保存和恢复，注意，浮点寄存器和XMM寄存器等不会被保存并恢复。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>state</td><td>取得协程的状态。 状态 可以为 STATE_STOPPED：未初始化状态，不可以作为切换的目标，当协程刚被创建或协程处理函数返回后的协程状态。 STATE_PAUSED：暂时状态，可作为切换的目标，协程被spawn后或切换到其他协和后，协程处于这种状态。 STATE_RUNNING：协程正在运行，正在运行的协程为当前协程。一个线程只有一个当前协程。 STATE_PENDING：未定状态，协程正在切换状态，具体状态将在协程完全切换成功后被设置。</td></tr><tr><td>stack_size</td><td>取得协程关联的栈空间大小。</td></tr><tr><td>yield (static)</td><td>从当前协程切换到另一个协程。</td></tr><tr><td>spawn (static)</td><td>初始化一个协程。使指定协程的状态由STATE_STOPPED转变成STATE_PAUSED，初始化后，可以作为协程切换的目标。</td></tr><tr><td>yield_last (static)</td><td>从当前协程切换到上一个协程（切换到当前协程的协程）。</td></tr><tr><td>yield_main (static)</td><td>从当前协程切换到线程关联的主协程。</td></tr><tr><td>this_coroutine (static)</td><td>取得当前协程。</td></tr><tr><td>main_coroutine (static)</td><td>取得主协程。（与线程直接关联的协程）</td></tr></tbody></table><br /><H1><a name="Event">Event</a>
</H1><hr /><P>事件类，内部有发生和未发生两种状态，默认为未发生状态。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>wait</td><td>等待事件发生。</td></tr><tr><td>wait_for</td><td>等待事件发生或超时。</td></tr><tr><td>wait_until</td><td>等待事件发生或到某个时间点到达。</td></tr><tr><td>set</td><td>设置事件为已发生状态。</td></tr><tr><td>reset</td><td>重置事件为未发生状态。</td></tr></tbody></table><br /><H1><a name="LockGuard">LockGuard</a>
</H1><hr /><P>class LockGuard</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody></tbody></table><br /><H1><a name="Mutex">Mutex</a>
</H1><hr /><P>Mutex，最基本的锁。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>lock</td><td>锁定Mutex，如果Mutex已经锁定，则阻塞，直接Mutex被解锁。</td></tr><tr><td>unlock</td><td>解除锁定，Mutex必须是已经锁定的并且由本线程锁定。</td></tr><tr><td>trylock</td><td>尝试锁定Mutex，如果Mutex已经锁定，返回假，否则锁定Mutex，并返回真。</td></tr></tbody></table><br /><H1><a name="RwLock">RwLock</a>
</H1><hr /><P>读写锁。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>lock_r</td><td>锁定读。</td></tr><tr><td>unlock_r</td><td>解除读锁定。</td></tr><tr><td>lock_w</td><td>锁定写。</td></tr><tr><td>unlock_w</td><td>解除写锁定。</td></tr></tbody></table><br /><H1><a name="Semaphore">Semaphore</a>
</H1><hr /><P>信号量。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>wait</td><td>等待信号量。</td></tr><tr><td>wait_for</td><td>等待信号量或超时。</td></tr><tr><td>wait_until</td><td>等待信号量或某个时间点达到。</td></tr><tr><td>post</td><td>投递信号。</td></tr><tr><td>try_wait</td><td>尝试等待信号量。</td></tr></tbody></table><br /><H1><a name="SpinLock">SpinLock</a>
</H1><hr /><P>自旋锁，不可以递规调用。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>lock</td><td>锁定SpinLock，如果SpinLock已经锁定，则等待SpinLock被解锁。</td></tr><tr><td>unlock</td><td>解除锁定。</td></tr><tr><td>trylock</td><td>尝试锁定SpinLock，如果SpinLock已经锁定，返回假，否则锁定SpinLock，并返回真。</td></tr></tbody></table><br /><H1><a name="Thread">Thread</a>
</H1><hr /><P>线程基类，内部可包含一个或多个线程。默认的线程入口点为Thread::svc。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor) (virtual)</td><td>析构函数。</td></tr><tr><td>wait</td><td>等待线程退出。</td></tr><tr><td>wait_for</td><td>等待线程退出或超时。</td></tr><tr><td>wait_until</td><td>等待线程退出或到达某个时间点。</td></tr><tr><td>activate</td><td>启动线程。</td></tr><tr><td>svc (virtual)</td><td>默认的线程入口函数。</td></tr><tr><td>alive</td><td>是否有活动的线程。</td></tr><tr><td>count</td><td>活动线程的数量。</td></tr><tr><td>reqexit</td><td>请求线程退出。发出请求后，线程调用test_destroy()函数会返回true，线程应当隔一段时间调用这个函数来判断是否应退出。</td></tr><tr><td>pause</td><td>暂时线程，会导致线程的test_destroy()函数阻塞。</td></tr><tr><td>resume</td><td>取消暂停，让阻塞在test_destory()里的线程继续运行。</td></tr><tr><td>yield (static)</td><td>提示可以切换线程。</td></tr><tr><td>sleep_for</td><td>当前线程睡眠一个时间间隔。</td></tr><tr><td>sleep_until</td><td>当前线程睡眠直到某个时间点到达。</td></tr><tr><td>test_destroy (virtual)</td><td>判断是否有退出请求。</td></tr><tr><td>set_affinity (static)</td><td>设置当前线程与CPU的关联。必须小于CPU核数或为-1。当值为-1时取消关联。</td></tr><tr><td>set_priority (static)</td><td>设置当前线程的优先级，50为普通级别，这个值越大优先级越高。</td></tr><tr><td>this_thread (static)</td><td>返回当前线程对象。</td></tr><tr><td>main_thread (static)</td><td>返回主线程对象。</td></tr></tbody></table><br /><H1><a name="ThreadCustom">ThreadCustom</a>
</H1><hr /><P>自定义线程类，内部可以自己定义一组入口函数，在activate时，会启动同样多的线程，每个线程各自调用对应的入口函数。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor) (virtual)</td><td>析构函数。</td></tr><tr><td>activate (virtual)</td><td>使用内部预先定义好的线程入口函数启动线程。</td></tr></tbody></table><br /><H1><a name="ThreadEx">ThreadEx</a>
</H1><hr /><P>线程扩展类，允许用仿函数来定义函数入口。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor) (virtual)</td><td>析构函数。</td></tr><tr><td>activate (virtual)</td><td>使用指定的线程入口函数启动线程。</td></tr></tbody></table><br /><H1><a name="ThreadManager">ThreadManager</a>
</H1><hr /><P>线程管理器，负责线程的创建和销毁等。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>close</td><td>关闭线程管理器，关闭后，不可以再创建新线程。</td></tr><tr><td>wait</td><td>等待所有线程退出。</td></tr><tr><td>count</td><td>取得活动线程的数量。</td></tr><tr><td>ok</td><td>判断线程管理器是否已经关闭。如果未关闭，返回真，否则返回假。</td></tr><tr><td>current (static)</td><td>取得当前的线程管理器对象。</td></tr></tbody></table><br /><H1><a name="ThreadMulti">ThreadMulti</a>
</H1><hr /><P>内部含多个线程。可以在启动时指定线程数量。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor) (virtual)</td><td>析构函数。</td></tr><tr><td>activate (virtual)</td><td>启动指定个数的线程，入口点为Thread::svc。</td></tr></tbody></table><br /></div></body></html>