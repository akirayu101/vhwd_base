<html><head><title>threading</title><link rel="Stylesheet" type="text/css" href="DocStyle.css" /></head><body><div><H1><a name="Condition">Condition</a>
</H1><hr /><P>条件类，与Mutex一起使用。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>wait</td><td>等待事件发生。</td></tr><tr><td>wait_for</td><td>等待事件发生或超时。</td></tr><tr><td>wait_until</td><td>等待事件发生或到某个时间点。</td></tr><tr><td>notify_one</td><td>唤醒一个等待的线程。</td></tr><tr><td>notify_all</td><td>唤醒所有等待的线程。</td></tr></tbody></table><br /><H1><a name="Event">Event</a>
</H1><hr /><P>事件类，内部有发生和未发生两种状态，默认为未发生状态。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>wait</td><td>等待事件发生。</td></tr><tr><td>wait_for</td><td>等待事件发生或超时。</td></tr><tr><td>wait_until</td><td>等待事件发生或到某个时间点到达。</td></tr><tr><td>set</td><td>设置事件为已发生状态。</td></tr><tr><td>reset</td><td>重置事件为未发生状态。</td></tr></tbody></table><br /><H1><a name="LockGuard">LockGuard</a>
</H1><hr /><P>class LockGuard</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody></tbody></table><br /><H1><a name="Mutex">Mutex</a>
</H1><hr /><P>Mutex，最基本的锁。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>lock</td><td>锁定Mutex，如果Mutex已经锁定，则阻塞，直接Mutex被解锁。</td></tr><tr><td>unlock</td><td>解除锁定，Mutex必须是已经锁定的并且由本线程锁定。</td></tr><tr><td>trylock</td><td>尝试锁定Mutex，如果Mutex已经锁定，返回假，否则锁定Mutex，并返回真。</td></tr></tbody></table><br /><H1><a name="RwLock">RwLock</a>
</H1><hr /><P>读写锁。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>lock_r</td><td>锁定读。</td></tr><tr><td>unlock_r</td><td>解除读锁定。</td></tr><tr><td>lock_w</td><td>锁定写。</td></tr><tr><td>unlock_w</td><td>解除写锁定。</td></tr></tbody></table><br /><H1><a name="Semaphore">Semaphore</a>
</H1><hr /><P>信号量。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>wait</td><td>等待信号量。</td></tr><tr><td>wait_for</td><td>等待信号量或超时。</td></tr><tr><td>wait_until</td><td>等待信号量或某个时间点达到。</td></tr><tr><td>post</td><td>投递信号。</td></tr><tr><td>try_wait</td><td>尝试等待信号量。</td></tr></tbody></table><br /><H1><a name="SpinLock">SpinLock</a>
</H1><hr /><P>自旋锁，不可以递规调用。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>lock</td><td>锁定SpinLock，如果SpinLock已经锁定，则等待SpinLock被解锁。</td></tr><tr><td>unlock</td><td>解除锁定。</td></tr><tr><td>trylock</td><td>尝试锁定SpinLock，如果SpinLock已经锁定，返回假，否则锁定SpinLock，并返回真。</td></tr></tbody></table><br /><H1><a name="Thread">Thread</a>
</H1><hr /><P>线程基类，内部可包含一个或多个线程。默认的线程入口点为Thread::svc。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor) (virtual)</td><td>析构函数。</td></tr><tr><td>wait</td><td>等待线程退出。</td></tr><tr><td>wait_for</td><td>等待线程退出或超时。</td></tr><tr><td>wait_until</td><td>等待线程退出或到达某个时间点。</td></tr><tr><td>activate</td><td>启动线程。</td></tr><tr><td>svc (virtual)</td><td>默认的线程入口函数。</td></tr><tr><td>alive</td><td>是否有活动的线程。</td></tr><tr><td>count</td><td>活动线程的数量。</td></tr><tr><td>reqexit</td><td>请求线程退出。发出请求后，线程调用test_destroy()函数会返回true，线程应当隔一段时间调用这个函数来判断是否应退出。</td></tr><tr><td>pause</td><td>暂时线程，会导致线程的test_destroy()函数阻塞。</td></tr><tr><td>resume</td><td>取消暂停，让阻塞在test_destory()里的线程继续运行。</td></tr><tr><td>yield (static)</td><td>提示可以切换线程。</td></tr><tr><td>sleep_for</td><td>当前线程睡眠一个时间间隔。</td></tr><tr><td>sleep_until</td><td>当前线程睡眠直到某个时间点到达。</td></tr><tr><td>test_destroy (virtual)</td><td>判断是否有退出请求。</td></tr><tr><td>set_affinity (static)</td><td>设置当前线程与CPU的关联。必须小于CPU核数或为-1。当值为-1时取消关联。</td></tr><tr><td>set_priority (static)</td><td>设置当前线程的优先级，50为普通级别，这个值越大优先级越高。</td></tr><tr><td>this_thread (static)</td><td>返回当前线程对象。</td></tr><tr><td>main_thread (static)</td><td>返回主线程对象。</td></tr></tbody></table><br /><H1><a name="ThreadCustom">ThreadCustom</a>
</H1><hr /><P>自定义线程类，内部可以自己定义一组入口函数，在activate时，会启动同样多的线程，每个线程各自调用对应的入口函数。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor) (virtual)</td><td>析构函数。</td></tr><tr><td>activate (virtual)</td><td>使用内部预先定义好的线程入口函数启动线程。</td></tr></tbody></table><br /><H1><a name="ThreadEx">ThreadEx</a>
</H1><hr /><P>线程扩展类，允许用仿函数来定义函数入口。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor) (virtual)</td><td>析构函数。</td></tr><tr><td>activate (virtual)</td><td>使用指定的线程入口函数启动线程。</td></tr></tbody></table><br /><H1><a name="ThreadMulti">ThreadMulti</a>
</H1><hr /><P>内部含多个线程。可以在启动时指定线程数量。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor) (virtual)</td><td>析构函数。</td></tr><tr><td>activate (virtual)</td><td>启动指定个数的线程，入口点为Thread::svc。</td></tr></tbody></table><br /><H1><a name="ThreadPool">ThreadPool</a>
</H1><hr /><P>线程池类，用来控制线程的创建等。</P><table><thead><tr><td class=col_name>Member Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td>(constructor)</td><td>构造函数。</td></tr><tr><td>(destructor)</td><td>析构函数。</td></tr><tr><td>close</td><td>关闭线程池，关闭后，档可以再创建线程。</td></tr><tr><td>wait</td><td>等待所有线程退出。</td></tr><tr><td>count</td><td>取得当前共有多少活动线程。</td></tr><tr><td>ok</td><td>判断ThreadPool是否已经关闭。如果未关闭，返回真，否则返回假。</td></tr><tr><td>current (static)</td><td>取得当前的线程池对象。一般不独立创建其他的线程池。</td></tr></tbody></table><br /></div></body></html>