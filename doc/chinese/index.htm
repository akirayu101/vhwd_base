<html><head><title>vhwd c++ library 1.0</title><link rel="Stylesheet" type="text/css" href="DocStyle.css" /></head><body><div><H1>vhwd c++ library 1.0</H1><hr /><div>vhwd c++ library 1.0 是一个跨平台的轻量级的C++库，目前主要支持Windows和Linux。本库基于系统API直接进行封装，不依赖第三方库，内部分为basic，logging，threading，net，ipc，memory，serialization和xml等几部分。<br /><ol><li><a href="#basic">basic</a>
</li><li><a href="#Logging">Logging</a>
</li><li><a href="#threading">threading</a>
</li><li><a href="#net">net</a>
</li><li><a href="#ipc">ipc</a>
</li><li><a href="#memory">memory</a>
</li><li><a href="#serialization">serialization</a>
</li><li><a href="#xml">xml</a>
</li></ol><br /><br /></div><hr /><H2><a name="basic">basic</a>
</H2><hr /><div>包括一些较基础的内容，包括字符串，Object，智能指针，时间，控制台，系统等内容。</div><P>Classes</P><table><thead><tr><td class=col_name>Class Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="basic.htm#AutoPtrT">AutoPtrT (template)</a>
</td><td>AutoPtrT，持有内容，在析构时删掉指向的内容。</td></tr><tr><td><a href="basic.htm#BitFlags">BitFlags</a>
</td><td>bit标识类，一般情况下使用一个整数，用|或&之类位运行符进行操作，这里进行了封装，可用函数来设置或获取指定的标识位。</td></tr><tr><td><a href="basic.htm#Clock">Clock</a>
</td><td>时钟类，用来获取系统当前的时间。</td></tr><tr><td><a href="basic.htm#CodeCvt">CodeCvt (template)</a>
</td><td>宽窄字符串互相转换的辅助类。</td></tr><tr><td><a href="basic.htm#Console">Console</a>
</td><td>控制台类，可以设置输出的颜色，可以从控制台读取或输出数据。</td></tr><tr><td><a href="basic.htm#DataPtrT">DataPtrT (template)</a>
</td><td>DataPtrT，T必须是ObjectData的继承类，会管理ObjectData的计数，在计数为0时释放指向内容。</td></tr><tr><td><a href="basic.htm#Exception">Exception</a>
</td><td>异常类。 一般我们不直接抛出异常，而是采用函数的方式来抛出异常，Exception类里定义了一系列的以X开头的抛出异常的函数。采用函数的方式抛出异常，可较方便统一控制一些行为，如某种行为时写系统的Log信息等的，如果每个地方直接使用throw来抛出异常，则很难统一控制。</td></tr><tr><td><a href="basic.htm#Factor">Factor</a>
</td><td>仿函数，可用来绑定各种函数及函数的参数。</td></tr><tr><td><a href="basic.htm#LitePtrT">LitePtrT (template)</a>
</td><td>LitePtrT，跟T*类似，但能保证初始化为NULL。</td></tr><tr><td><a href="basic.htm#NonCopyable">NonCopyable</a>
</td><td>阻止继承类被拷贝或赋值。</td></tr><tr><td><a href="basic.htm#Object">Object</a>
</td><td>Object类，是库中的很多类的公共基类，带有一个类信息，定义了系列化相关的虚函数。如果一个类，具有继承关系并希望被系列化，那么，这个类就必须从Object继承。</td></tr><tr><td><a href="basic.htm#ObjectCreator">ObjectCreator</a>
</td><td>用于使用类名创建类实例。Object继承类，如果定义了关联的ObjectInfo，那么，在关联的ObjectInfo构造时，会自动注册到ObjectCreator中。</td></tr><tr><td><a href="basic.htm#ObjectData">ObjectData</a>
</td><td>自带计算数的Object继承类，在计数器值为0时，释放对象，ObjectData类及其继承类，一般只在堆空间分配，一般以指针或智能指针的形式使用。</td></tr><tr><td><a href="basic.htm#ObjectInfo">ObjectInfo</a>
</td><td>类信息，用于详细描述类的信息，并带有创建类实例的方法。</td></tr><tr><td><a href="basic.htm#String">String</a>
</td><td>字符串类。</td></tr><tr><td><a href="basic.htm#System">System</a>
</td><td>系统类，用于获取一些跟系统相关的信息，也用于控制系统级的Log信息输出。</td></tr><tr><td><a href="basic.htm#TimeDetail">TimeDetail</a>
</td><td>时间细节类，用于比较简单的方式来表示时间，可以直接取得年份月份等，或转换成字符串等。</td></tr><tr><td><a href="basic.htm#TimePoint">TimePoint</a>
</td><td>TimePoint表示一个时间点，可以精确到微秒。 相当于一全time_t和一个微秒的偏移。</td></tr><tr><td><a href="basic.htm#TimeSpan">TimeSpan</a>
</td><td>TimeSpan用于表示一个时间间隔，可以精确到微秒。</td></tr></tbody></table><br /><br /><H2><a name="Logging">Logging</a>
</H2><hr /><div>Logging日志系统，主要分为Logger和LogTarget。Logger可以关联一个LogTarget，LogTarget为消息真正的处理者，Logger主要负责收集信息并发送到LogTarget。每个线程有个私有的Logger，可以使用this_logger来获得当前线程私有的Logger。一般的函数，如果需要输出一些附加的信息，我们一般是写到线程关联的Logger中，不需要关心消息在哪里被如何处理。调用函数前，如果要控制消息，可以设置一个合适的LogTarget即可，也可以使用自己定义的Logger来替换线程的当前Logger。</div><P>Classes</P><table><thead><tr><td class=col_name>Class Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="Logging.htm#LogConsole">LogConsole</a>
</td><td>打印信息到控制台的LogTarget。</td></tr><tr><td><a href="Logging.htm#LogFile">LogFile</a>
</td><td>保存信息到文件的LogTarget。</td></tr><tr><td><a href="Logging.htm#LogNull">LogNull</a>
</td><td>空的LogTarget，此LogTarget会忽略所有发送给它的LogRecord。</td></tr><tr><td><a href="Logging.htm#LogPtr">LogPtr</a>
</td><td>可重定义LogTarget的LogTarget。</td></tr><tr><td><a href="Logging.htm#LogRecord">LogRecord</a>
</td><td>Logger的消息定义，包括消息的描述，生成消息的时间，消息源，消息级别，线程ID。</td></tr><tr><td><a href="Logging.htm#LogTarget">LogTarget</a>
</td><td>Logger的目标类，用于处理Logger发送过来的LogRecord。</td></tr><tr><td><a href="Logging.htm#Logger">Logger</a>
</td><td>Logger类。</td></tr><tr><td><a href="Logging.htm#LoggerSwap">LoggerSwap</a>
</td><td>LoggerSwap，用来临时替换线程私有的Logger。</td></tr></tbody></table><br /><P>Functions</P><table><thead><tr><td class=col_name>Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="Logging.htm#this_logger">this_logger</a>
</td><td>取得线程的私有的Logger。</td></tr></tbody></table><br /><br /><H2><a name="threading">threading</a>
</H2><hr /><div>线程库，包括各种锁，线程类等。</div><P>Classes</P><table><thead><tr><td class=col_name>Class Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="threading.htm#Condition">Condition</a>
</td><td>条件类，与Mutex一起使用。</td></tr><tr><td><a href="threading.htm#Event">Event</a>
</td><td>事件类，内部有发生和未发生两种状态，默认为未发生状态。</td></tr><tr><td><a href="threading.htm#LockGuard">LockGuard</a>
</td><td>class LockGuard</td></tr><tr><td><a href="threading.htm#Mutex">Mutex</a>
</td><td>Mutex，最基本的锁。</td></tr><tr><td><a href="threading.htm#RwLock">RwLock</a>
</td><td>读写锁。</td></tr><tr><td><a href="threading.htm#Semaphore">Semaphore</a>
</td><td>信号量。</td></tr><tr><td><a href="threading.htm#SpinLock">SpinLock</a>
</td><td>自旋锁，不可以递规调用。</td></tr><tr><td><a href="threading.htm#Thread">Thread</a>
</td><td>线程基类，内部可包含一个或多个线程。默认的线程入口点为Thread::svc。</td></tr><tr><td><a href="threading.htm#ThreadCustom">ThreadCustom</a>
</td><td>自定义线程类，内部可以自己定义一组入口函数，在activate时，会启动同样多的线程，每个线程各自调用对应的入口函数。</td></tr><tr><td><a href="threading.htm#ThreadEx">ThreadEx</a>
</td><td>线程扩展类，允许用仿函数来定义函数入口。</td></tr><tr><td><a href="threading.htm#ThreadMulti">ThreadMulti</a>
</td><td>内部含多个线程。可以在启动时指定线程数量。</td></tr><tr><td><a href="threading.htm#ThreadPool">ThreadPool</a>
</td><td>线程池类，用来控制线程的创建等。</td></tr></tbody></table><br /><br /><H2><a name="net">net</a>
</H2><hr /><div>网络库，包括IPAddress，Socket，IOCPPool和Session等。</div><P>Classes</P><table><thead><tr><td class=col_name>Class Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="net.htm#IOCPPool">IOCPPool</a>
</td><td>异步IO类。</td></tr><tr><td><a href="net.htm#IPAddress">IPAddress</a>
</td><td>IP地址描述类。</td></tr><tr><td><a href="net.htm#PerIO_buffer">PerIO_buffer</a>
</td><td>一次异步IO操作的buffer。</td></tr><tr><td><a href="net.htm#Session">Session</a>
</td><td>异步IO的对话类。</td></tr><tr><td><a href="net.htm#SessionClient">SessionClient</a>
</td><td>TCP协议的客户端对话类。调用Connect函数成功连接后，认为是Connected。</td></tr><tr><td><a href="net.htm#SessionServer">SessionServer</a>
</td><td>TCP协议的服务器端对话类。仅用于接收新的连接请求，在绑定端口成功Listen后，认为是Connected，默认的OnConnected函数是调用WaitForAccept。 在接受新连接请求后，会调用NewSession这个函数，这个函数必须创建一个合适的Session来处理新的连接。</td></tr><tr><td><a href="net.htm#SessionTCP">SessionTCP</a>
</td><td>TCP协议异步IO的对话类。有两种通信模式，第一种为 使用AsyncSend/OnSendCompleted 和 AsyncRecv/OnRecvCompleted接口进行通信，另一种为 使用WaitForSend/OnSendReady 和 WaitForRecv/OnRecvReady 接口进行通信。 这两种接口也可以但不建议混合使用。</td></tr><tr><td><a href="net.htm#SessionUDP">SessionUDP</a>
</td><td>UDP协议的异步IO的对话类。使用AsyncSend/OnSendCompleted 和 AsyncRecv/OnRecvCompleted接口进行通信。 SessionUDP不区分服务器端或客户端，在执行Bind之后，就认为是Connected，这时的OnConnected函数，服务器端第一个动作是调用AsyncRecv，而客户端第一个动作是调用AsyncSend。</td></tr><tr><td><a href="net.htm#Socket">Socket</a>
</td><td>Socket类。</td></tr></tbody></table><br /><br /><H2><a name="ipc">ipc</a>
</H2><hr /><div>进程间通信类，主要包括管道，命名管道，共享内存和基于共享内存的Buffer和无锁队列。</div><P>Classes</P><table><thead><tr><td class=col_name>Class Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="ipc.htm#NamedPipe">NamedPipe</a>
</td><td>命名管道类。</td></tr><tr><td><a href="ipc.htm#Pipe">Pipe</a>
</td><td>管道类。</td></tr><tr><td><a href="ipc.htm#SharedMem">SharedMem</a>
</td><td>共享内存类。</td></tr><tr><td><a href="ipc.htm#SharedMemQueue">SharedMemQueue</a>
</td><td>基于共享内存的无锁循环队列，此队列包括指定数量指定大小的定长Buffer，一个用于分配Buffer的队列，还有两个使用非负整数作为元素的辅助队列。队列中一般存放Buffer Index。一般的用法，某进程从队列中取得一个空闲的Buffer Index，然后把数据写到Buffer中，然后把这个Buffer Index加入到辅助队列1或辅助队列2中，然后由其他进程从辅助队列中取得这个Buffer Index，再根据Buffer Index找到数据并进行处理，然后归还这个Buffer Index或再次加入到辅助队列中。</td></tr></tbody></table><br /><br /><H2><a name="memory">memory</a>
</H2><hr /><div>内存，主要包括对齐的内存分配释放函数，内存池，还有对齐的内存分配器或使用内存池的内存分配器。</div><P>Classes</P><table><thead><tr><td class=col_name>Class Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="memory.htm#Allocator">Allocator</a>
</td><td>可指定内存对齐量的内存分配器，也可以控制在分配的内存前面分配一个类型E的实例。</td></tr><tr><td><a href="memory.htm#AllocatorUsePool">AllocatorUsePool</a>
</td><td>使用内存池的内存分配器。</td></tr><tr><td><a href="memory.htm#MemPoolDebug">MemPoolDebug</a>
</td><td>Debug版的内存池，在分配的内存前面加上分配信息。配合宏MEM_DEBUG，可用来检测内存泄露等。</td></tr><tr><td><a href="memory.htm#MemPoolMalloc">MemPoolMalloc</a>
</td><td>使用malloc/free的内存池。</td></tr><tr><td><a href="memory.htm#MemPoolPaging">MemPoolPaging</a>
</td><td>MemPoolPaging，使用内存页为基础的内存池，内部使用多个定长分配器。不同MemPoolPaging分配的内存可以交叉释放，由malloc分配的内存，也可以由MemPoolPaging释放。</td></tr></tbody></table><br /><P>Functions</P><table><thead><tr><td class=col_name>Function Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="memory.htm#AlignedAlloc">AlignedAlloc</a>
</td><td>对齐的内存分配函数，使用AlignedFree释放内存。</td></tr><tr><td><a href="memory.htm#AllignedFree">AllignedFree</a>
</td><td>对齐的内存释放函数，用于释放AllignedAlloc分配出来的内存。</td></tr></tbody></table><br /><br /><H2><a name="serialization">serialization</a>
</H2><hr /><div>二进制系列化器。可以系列化基本的类型，String，Object及其继承类，或定义了自定义系列化方法的结构体，及这些类型的指针，或这些类型及其指针为元素的可系列化容器。使用 operator&进行系列化。</div><P>Classes</P><table><thead><tr><td class=col_name>Class Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="serialization.htm#Serializer">Serializer</a>
</td><td>系列化器。</td></tr><tr><td><a href="serialization.htm#SerializerReader">SerializerReader</a>
</td><td>读系列化器。</td></tr><tr><td><a href="serialization.htm#SerializerReaderSocket">SerializerReaderSocket</a>
</td><td>使用Socket的读系列化器。</td></tr><tr><td><a href="serialization.htm#SerializerReaderStream">SerializerReaderStream</a>
</td><td>使用std::istream的读系列化器。</td></tr><tr><td><a href="serialization.htm#SerializerWriter">SerializerWriter</a>
</td><td>写系列化器。</td></tr><tr><td><a href="serialization.htm#SerializerWriterSocket">SerializerWriterSocket</a>
</td><td>使用Socket的写系列化器。</td></tr><tr><td><a href="serialization.htm#SerializerWriterStream">SerializerWriterStream</a>
</td><td>使用std::ostream的写系列化器。</td></tr></tbody></table><br /><br /><H2><a name="xml">xml</a>
</H2><hr /><div>xml库</div><P>Classes</P><table><thead><tr><td class=col_name>Class Name</td><td class=col_desc>Desc</td></tr></thead><tbody><tr><td><a href="xml.htm#XmlAttribute">XmlAttribute</a>
</td><td>Xml属性定义。</td></tr><tr><td><a href="xml.htm#XmlDocument">XmlDocument</a>
</td><td>Xml文档类</td></tr><tr><td><a href="xml.htm#XmlNode">XmlNode</a>
</td><td>Xml节点定义。</td></tr></tbody></table><br /><br /></div></body></html>